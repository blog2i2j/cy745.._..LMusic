package com.lalilu.voyager.router

import com.google.devtools.ksp.KspExperimental
import com.google.devtools.ksp.getAllSuperTypes
import com.google.devtools.ksp.getAnnotationsByType
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.processing.SymbolProcessorProvider
import com.google.devtools.ksp.symbol.ClassKind
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSDeclaration
import com.google.devtools.ksp.symbol.Nullability
import com.lalilu.voyager.router.annotation.Param
import com.lalilu.voyager.router.annotation.Route
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.buildCodeBlock

@OptIn(KspExperimental::class)
class RouterProcessor : SymbolProcessorProvider, SymbolProcessor {

    private lateinit var logger: KSPLogger
    private lateinit var codeGenerator: CodeGenerator

    companion object {
        const val DefaultIndent = "    "

        const val ApiPackage = "com.lalilu.voyager.router.api"
        const val VRouter = "com.lalilu.voyager.router.api.VRouter"
        const val Screen = "cafe.adriel.voyager.core.screen.Screen"
        const val RouteItem = "com.lalilu.voyager.router.api.RouteItem"
        const val RouteResult = "com.lalilu.voyager.router.api.RouteResult"
        const val RouteResult_Success = "com.lalilu.voyager.router.api.RouteResult.Success"
        const val RouteResult_None = "com.lalilu.voyager.router.api.RouteResult.None"
        const val RouteResult_Error = "com.lalilu.voyager.router.api.RouteResult.Error"

        const val RouteFile = "VRouter\$Routes.kt"
        const val RouteClassName = "VRouter\$Routes"
        const val RouteFileKdoc = "DO NOT EDIT THIS FIlE, This file is generated by ksp."
    }


    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        logger = environment.logger
        codeGenerator = environment.codeGenerator

        log("RouterProcessor created.")
        return this
    }

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val fileCreated = resolver.getNewFiles()
            .toList()
            .any { it.packageName.asString() == ApiPackage && it.fileName == RouteFile }

        // 若已经产生了 RouteFile 则跳过
        if (fileCreated) {
            log("$RouteFile is created. skip")
            return emptyList()
        }

        val classDeclarations = resolver.getAllFiles()
            .map { file -> file.declarations.mapNotNull { it as? KSClassDeclaration } }
            .flatten()
            .filter { item ->
                item.getAllSuperTypes()
                    .any { it.declaration.toClassName() == Screen }
            }.toList()

        log("Found ${classDeclarations.size} Screen classes.")
        if (classDeclarations.isEmpty()) {
            return emptyList()
        }

        val initCode = CodeBlock.builder()
        classDeclarations.forEach { singleRegister(initCode, it) }

        val fileSpec = FileSpec.builder(ApiPackage, RouteClassName)
            .addType(
                TypeSpec.objectBuilder(RouteClassName)
                    .addKdoc(RouteFileKdoc)
                    .addInitializerBlock(initCode.build())
                    .build()
            )
            .indent(DefaultIndent)
            .build()

        val file = codeGenerator
            .createNewFile(Dependencies.ALL_FILES, fileSpec.packageName, fileSpec.name)
        file.write(fileSpec.toString().toByteArray())

        return emptyList()
    }

    private fun singleRegister(codeBlock: CodeBlock.Builder, declaration: KSClassDeclaration) {
        baseRegister(codeBlock, declaration) {
            when (declaration.classKind) {
                ClassKind.OBJECT -> {
                    add(
                        "%T(%T)",
                        ClassName.bestGuess(RouteResult_Success),
                        ClassName.bestGuess(declaration.toClassName())
                    )
                }

                ClassKind.CLASS -> {
                    val keys = mutableSetOf<String>()
                    declaration.primaryConstructor?.parameters?.forEach { param ->
                        val paramAnnotation = param
                            .getAnnotationsByType(Param::class)
                            .firstOrNull()

                        val paramName = param.name?.asString()!!
                        val keyName = paramAnnotation?.key ?: paramName

                        val type = param.type.resolve()
                        val typeName = type.declaration.toClassName()
                        val typeCanBeNull = type.nullability == Nullability.NULLABLE
                        val typeIsListType = typeName == "kotlin.collections.List"

                        if (typeIsListType) {
                            val genericsTypeName = type.arguments.firstNotNullOf {
                                it.type?.resolve()?.declaration?.toClassName()
                            }

                            addStatement(
                                "val %L = getMapByListType(%T::class.java)[\"%L\"]",
                                paramName,
                                ClassName.bestGuess(genericsTypeName),
                                keyName
                            )
                        } else {
                            addStatement(
                                "val %L = getMapByType(%T::class.java)[\"%L\"]",
                                paramName,
                                ClassName.bestGuess(typeName),
                                keyName
                            )
                        }

                        // 不能为空的参数需要进行校验
                        if (!typeCanBeNull) {
                            addStatement(
                                "if(%L == null) { return@RouteItem %T(\"%L\") }",
                                paramName,
                                ClassName.bestGuess(RouteResult_Error),
                                "$paramName cannot be null"
                            )
                        }

                        keys.add(paramName)
                    }

                    add(
                        "%T(%T(%L))",
                        ClassName.bestGuess(RouteResult_Success),
                        ClassName.bestGuess(declaration.toClassName()),
                        keys.joinToString(",") { "$it = $it" }
                    )
                }

                else -> {
                    add("%T", ClassName.bestGuess(RouteResult_None))
                }
            }
        }
    }

    private fun baseRegister(
        codeBlock: CodeBlock.Builder,
        declaration: KSClassDeclaration,
        codeBlockCallback: CodeBlock.Builder.() -> Unit
    ) {
        val routeAnnotation = declaration.getAnnotationsByType(Route::class)
            .firstOrNull()

        val path = routeAnnotation?.path ?: "/pages/${declaration.simpleName.asString()}"
        val remark = routeAnnotation?.remark ?: declaration.docString ?: ""

        codeBlock.add("""
            |%T.register(
            |    %T(
            |        path = "%L",
            |        remark = "%L"
            |    ) {
            |        %L
            |    }
            |)
            |""".trimMargin(),
            ClassName.bestGuess(VRouter),
            ClassName.bestGuess(RouteItem),
            path,
            remark,
            buildCodeBlock {
                codeBlockCallback()
            }
        )
    }

    private fun log(message: String) {
        logger.warn(message)
    }

    private fun KSDeclaration.toClassName(): String {
        return "${packageName.asString()}.${simpleName.asString()}"
    }
}